\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}       % For \url{...}
\usepackage{amssymb}        % Math symbols
\usepackage{amsmath}        % Various commands like \text{...}
\usepackage{mathtools}      %
\usepackage{algpseudocode}  % Pseudocode printer
\usepackage{listings}       % Source code printer
\usepackage{framed}         % To frame the computational cost

\title{Advanced Algorithms Problems and Solutions}
\author{Mattia Setzu}
\date{October 2016}

\lstset{numbers=left} % Print line numbers in \begin{lstlisting}...

\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{Hogwarts}

The Hogwarts School\footnote{\url{http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/magistraleinformatica/alg2/algo2_16/hogwarts.pdf}} is modeled as a graph $G=(V, E)$ where $V$ is the set of castle's rooms and $E \subseteq V \times V$ is the set of the stairs. Each stair is labelled with the time of appearance and disappearance, and can be walked in both directions, therefore the graph is undirected. The goal is to find, if possible, the minimum amount of time required to go from the first to the last room.

\subsection{Solution 1: Preprocessing-then-Dijkstra}

Dijkstra is able to find the shortest path in a graph with non-negative weights on its edges. Our main idea is to create a Dijkstra compatible graph through a \emph{normalize} function, then apply Dijkstra to it in order to find the shortest path.
The core of the preprocessing is the normalize function which computes traversal times between nodes at a given time \emph{time}:
\begin{algorithmic}[1]
  \Function{normalize}{$from$, $to$, $time$}:
    \State $t = \infty$
    \State \If{$start[v'] \leq t < end[v']$}    \Comment{No waiting time}
        \State t = t + 1\;
    \State \ElsIf{$t < start[v']$}              \Comment{Waiting time}
      \State t = start[v'] + 1\;
    \State \Else
      \State $t = \infty$\;                     \Comment{Available time already expired}
    \EndIf \\
      \Return{t}
    \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}: $\Theta(n^{2})$ if the vertex set is implemented as an array. $O(|E|+|V|\log |V|)$ with Fibonacci heap.
\end{framed}

The normalize function is then applied to a node traversal:

\subsubsection{Pseudo-code}

\begin{algorithmic}[1]
  \State create vertex set Q of unvisited nodes\;
  \State create vertexes set E' of edges weight\;
  \State time = 0\;                   \Comment{Initial time for traversal}
  \State edges = stairs\_of(0)\;      \Comment{Get the incoming and outcoming edges of the starting node}

  \Function{process}{$node$, $time$}
  \State \If{$edge \in visited\_edges$}
    \Return{}
  \EndIf

  \State $traversal\_time = \infty$
  \For{each $neighbor \in neighbors\_of\_node$}
      \State traversal\_time = traversal\_time(node, neighbor, time)
      \State E'[0][node] = traversal\_time   \Comment{E'[i][j] holds the weight/traversal}
      \State \Comment{time for the stair between i and j}

      \For{each $new\_neighbor \in neighbors\_of\_neighbor$}
      \State normalize(neighbor, new\_neighbor, traversal\_time)
      \EndFor
  \EndFor

  \State dijkstra\_graph = \{V, E'\}
  \State t = dijkstra(dijkstra\_graph)
  \State \If{$t == \infty$} \Return{-1};
        \Else \Return{$t$};
        \EndIf
  \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}. See the previous section.
\end{framed}


\subsection{Solution 2: HogwartsDijkstra}

\begin{algorithmic}[1]
  \Function{HogwartsDijkstra}{$G$}:
  \State create vertex set $Q$ of unvisited nodes
  \For{each vertex $v \in V$}      \Comment{initialization}
      \State $time[v] \gets \infty$  \Comment{unknown time from source to v}
      \State add $v$ to $Q$          \Comment{all nodes initially in Q}
  \EndFor
  \State $time[0] \gets 0$ \Comment{time from source to source}
  \While{$Q\ne \emptyset$}
      \State $u \gets x \in Q$ with $\min\{time[x]\}$
      \State remove $u$ from $Q$
      \For{each neighbor $v$ of $u$}:
          \If{$time[u] \leq appear[v]$}
              \State $alt \gets appear[v] + 1$ \Comment{wait the appearance of the stair}
          \ElsIf{$time[u] < disappear[v]$}
              \State $alt \gets time[u] + 1$       \Comment{use the stair}
          \Else
              \State $alt \gets \infty$            \Comment{the stair has already disappeared}
          \EndIf
          \If{$alt < time[v]$}
              \State $time[v] \gets alt$           \Comment{a quicker path to $v$ has been found}
          \EndIf
      \EndFor
  \EndWhile
  \State \Return{$time[|N|-1]$}
  \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}. See the previous section.
\end{framed}

\subsection{Solution 3: BFS-like traversal}

\begin{algorithmic}[1]
  \Function{reach}{$N$, $M$, $A[]$, $B[]$, $appear[]$, $disappear[]$}
      \For{$i=0$ to $M-1$}
          \State $edges\_[A[i]].push\_back(make\_pair(i, B[i]))$
          \State $edges\_[B[i]].push\_back(make\_pair(i, A[i]))$
      \EndFor
      \For{$i=0$ to $N-1$}
          \State $done\_[i] \gets false$
          \State $distance\_[i] \gets \infty$
      \EndFor
      \State $reached\_[0].push\_back(0)$
    \State $distance\_[0] \gets 0$
    \For{$t=0$ to $MAX\_TIME$}
      \For{$v \in reached\_[t]$}
          \If{not $done\_[v]$}
          \For{$edge \in edges\_[v]$}
            \State $staircase \gets edge.first$
            \State $neighbor \gets edge.second$
            \State $time \gets max(distance_[v], appear[staircase])+1$
            \If{not $done\_[neighbor]$ \\ \hfill and $distance\_[v] < disappear[staircase]$ \\ \hfill and  $time < distance\_[neighbor]$}
              \State $distance\_[neighbor] \gets time$
              \State $reached\_[time].push\_back(neighbor)$
            \EndIf
          \EndFor
        \State $done\_[v] \gets true$
          \EndIf
      \EndFor
    \EndFor
    \State \Return{$(distance\_[N-1] == \infty) ? -1 : distance\_[N-1]$}
  \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}: $O(m + MAX\_TIME)$.
\end{framed}

\section{Paletta}
\href{http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/magistraleinformatica/alg2/algo2_16/paletta.pdf}{Problem description}.
\subsection{Solution 1: Split and count-inversions}

\section{Nemesis}
\href{http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/magistraleinformatica/alg2/algo2_16/nemesi.pdf}{Problem description}.
\subsection{Solution 1: Naive}

\subsection{Solution 2: Coloring}

\subsection{Solution 3: Ordered matrix}


\end{document}

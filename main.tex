\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}       % For \url{...}
\usepackage{amssymb}        % Math symbols
\usepackage{amsmath}        % Various commands like \text{...}
\usepackage{mathtools}      %
\usepackage{algpseudocode}  % Pseudocode printer
\usepackage{listings}       % Source code printer
\usepackage{framed}         % To frame the computational cost
\usepackage{qtree}          % Draw simple binary trees

\title{Advanced Algorithms Problems and Solutions}
\author{Mattia Setzu}
\date{October 2016}

\lstset{numbers=left} % Print line numbers in \begin{lstlisting}...

\begin{document}

\maketitle

\tableofcontents
\clearpage

\section{Hogwarts}

The Hogwarts School\footnote{\url{http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/magistraleinformatica/alg2/algo2_16/hogwarts.pdf}} is modeled as a graph $G=(V, E)$ where $V$ is the set of castle's rooms and $E \subseteq V \times V$ is the set of the stairs. Each stair is labelled with the time of appearance and disappearance, and can be walked in both directions, therefore the graph is undirected. The goal is to find, if possible, the minimum amount of time required to go from the first to the last room.

\subsection{Solution 1: Preprocessing-then-Dijkstra}

Dijkstra is able to find the shortest path in a graph with non-negative weights on its edges. Our main idea is to create a Dijkstra compatible graph through a \emph{normalize} function, then apply Dijkstra to it in order to find the shortest path.
The core of the preprocessing is the normalize function which computes traversal times between nodes at a given time \emph{time}:
\begin{algorithmic}[1]
  \Function{normalize}{$from$, $to$, $time$}:
    \State $t = \infty$
    \State \If{$start[v'] \leq t < end[v']$}    \Comment{No waiting time}
        \State t = t + 1\;
    \State \ElsIf{$t < start[v']$}              \Comment{Waiting time}
      \State t = start[v'] + 1\;
    \State \Else
      \State $t = \infty$\;                     \Comment{Available time already expired}
    \EndIf \\
      \Return{t}
    \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}: $\Theta(n^{2})$ if the vertex set is implemented as an array. $O(|E|+|V|\log |V|)$ with Fibonacci heap.
\end{framed}

The normalize function is then applied to a node traversal:

\subsubsection{Pseudo-code}

\begin{algorithmic}[1]
  \State create vertex set Q of unvisited nodes\;
  \State create vertexes set E' of edges weight\;
  \State time = 0\;                   \Comment{Initial time for traversal}
  \State edges = stairs\_of(0)\;      \Comment{Get the incoming and outcoming edges of the starting node}

  \Function{process}{$node$, $time$}
  \State \If{$edge \in visited\_edges$}
    \Return{}
  \EndIf

  \State $traversal\_time = \infty$
  \For{each $neighbor \in neighbors\_of\_node$}
      \State traversal\_time = traversal\_time(node, neighbor, time)
      \State E'[0][node] = traversal\_time   \Comment{E'[i][j] holds the weight/traversal}
      \State \Comment{time for the stair between i and j}

      \For{each $new\_neighbor \in neighbors\_of\_neighbor$}
      \State normalize(neighbor, new\_neighbor, traversal\_time)
      \EndFor
  \EndFor

  \State dijkstra\_graph = \{V, E'\}
  \State t = dijkstra(dijkstra\_graph)
  \State \If{$t == \infty$} \Return{-1};
        \Else \Return{$t$};
        \EndIf
  \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}. See the previous section.
\end{framed}


\subsection{Solution 2: HogwartsDijkstra}

\begin{algorithmic}[1]
  \Function{HogwartsDijkstra}{$G$}:
  \State create vertex set $Q$ of unvisited nodes
  \For{each vertex $v \in V$}      \Comment{initialization}
      \State $time[v] \gets \infty$  \Comment{unknown time from source to v}
      \State add $v$ to $Q$          \Comment{all nodes initially in Q}
  \EndFor
  \State $time[0] \gets 0$ \Comment{time from source to source}
  \While{$Q\ne \emptyset$}
      \State $u \gets x \in Q$ with $\min\{time[x]\}$
      \State remove $u$ from $Q$
      \For{each neighbor $v$ of $u$}:
          \If{$time[u] \leq appear[v]$}
              \State $alt \gets appear[v] + 1$ \Comment{wait the appearance of the stair}
          \ElsIf{$time[u] < disappear[v]$}
              \State $alt \gets time[u] + 1$       \Comment{use the stair}
          \Else
              \State $alt \gets \infty$            \Comment{the stair has already disappeared}
          \EndIf
          \If{$alt < time[v]$}
              \State $time[v] \gets alt$           \Comment{a quicker path to $v$ has been found}
          \EndIf
      \EndFor
  \EndWhile
  \State \Return{$time[|N|-1]$}
  \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}. See the previous section.
\end{framed}

\subsection{Solution 3: BFS-like traversal}

\begin{algorithmic}[1]
  \Function{reach}{$N$, $M$, $A[]$, $B[]$, $appear[]$, $disappear[]$}
      \For{$i=0$ to $M-1$}
          \State $edges\_[A[i]].push\_back(make\_pair(i, B[i]))$
          \State $edges\_[B[i]].push\_back(make\_pair(i, A[i]))$
      \EndFor
      \For{$i=0$ to $N-1$}
          \State $done\_[i] \gets false$
          \State $distance\_[i] \gets \infty$
      \EndFor
      \State $reached\_[0].push\_back(0)$
    \State $distance\_[0] \gets 0$
    \For{$t=0$ to $MAX\_TIME$}
      \For{$v \in reached\_[t]$}
          \If{not $done\_[v]$}
          \For{$edge \in edges\_[v]$}
            \State $staircase \gets edge.first$
            \State $neighbor \gets edge.second$
            \State $time \gets max(distance_[v], appear[staircase])+1$
            \If{not $done\_[neighbor]$ \\ \hfill and $distance\_[v] < disappear[staircase]$ \\ \hfill and  $time < distance\_[neighbor]$}
              \State $distance\_[neighbor] \gets time$
              \State $reached\_[time].push\_back(neighbor)$
            \EndIf
          \EndFor
        \State $done\_[v] \gets true$
          \EndIf
      \EndFor
    \EndFor
    \State \Return{$(distance\_[N-1] == \infty) ? -1 : distance\_[N-1]$}
  \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}: $O(m + MAX\_TIME)$.
\end{framed}

\section{Paletta}
Paletta ordering\footnote{\url{http://didawiki.cli.di.unipi.it/lib/exe/fetch.php/magistraleinformatica/alg2/algo2_16/paletta.pdf}} is a peculiar ordering technique: given a 3-tuple of elements, paletta takes the central element as pivot and swaps the two elements right before and next to it. To make an example:
\begin{equation}
  \textrm{\{3, 2, 1\}} \xrightarrow{paletta} \textrm{\{1, 2, 3\}}
\end{equation}
We now want to develop an algorithm to order any array through paletta ordering with the minimal number of swaps.
You should see as not every array can be ordered like this:
  \begin{equation}
  \textrm{\{3, , 1\}} \xrightarrow[]{paletta} \textrm{\{1, 2, 3\}}
  \end{equation}

\subsection{Solution 1: Split and count-inversions}
We should note that the following properties hold:
\begin{enumerate}
    \item Every element can be a pivot, but the first and the last one, as they have respectevly
    no elements before and after them.
    \item Every element can be swapped as many times as necessary, but only with elements of the
    same 2-remainder (numbers in even positions can only be swapped with numbers in even positions,
    the same holds for odd indexes).
    More formally $|a| = N, \forall i \in [1, N - 2], \neg \exists swap(i, j): i \mod 2 \neq i \mod j$
    \item The least number of swaps does not backtrack any element. Formally, let \emph{k} be the minimal number
    of swaps applied to an array, backtracks included. By hypothesis, \emph{k} is minimal, but at least \emph{m},
    $m > 0$ backtrack swaps have been operated, therefore we found a $k' = k - m: k' < k$, a new minimal number
    of swaps: contradiction.
\end{enumerate}
Given item 2, we can split our array in two, even and odd numbers, and order them counting the swaps.
In our example we'll use \emph{mergesort}, as it runs in $\log_2 n$, does not backtrack elements,
and is very well-known.
Clearly, given an array, a swap happens when an element is pushed back, pulling the one between its new position
and the old one ahead: we can map this behaviour in the merge routine of mergesort: the array merged is able to
push back elements from its right pointer to the new array, moving them back of $(m - i) + (j - m)$ positions,
where \emph{m} is the dimension of the current two sub-arrays to merge.
Provided that our edited version of mergesort ran successfully on both the even-index and odd-index, we now need
to verify if by merging them we obtain an ordered array.
Intuitively, the merged array will start with the first element of the even-index arrays, followed by the first
of the odd-index array, followed by the second of the even-index array, and so on.
To check for these elements is pretty trivial and can be done in linear time.
Follows the pseudo-code for the edited version and \emph{snake\_check} function:

\begin{algorithmic}[1]
  \Function{merge\_with\_paletta}{$left$, $right$, $k$}:
    \State ...\;                        \Comment{merge instructions}
    \State \If{$right > left$}
      \State paletta\_count = paletta\_count + 1\;
      \State ...\;
      \EndIf
    \EndFunction
\end{algorithmic}

\begin{algorithmic}[1]
  \Function{snake\_check}{}:
    \State even, odd = 0\;
    \For{;$even, odd < N\;even = even + 1, odd = odd + 1$}
      \State \If{$a[even] > a[odd]$}
        \State \Return{-1}\;
        \EndIf
    \EndFor

    \Return{paletta\_count}\;
    \EndFunction
\end{algorithmic}

\begin{framed}
  \noindent
  \textbf{Computational cost}: $\Omega(n\log_2(n)), \Theta(n\log_2(n)), O(n\log_2(n))$.
\end{framed}


\newpage
\section{Range updates}
Consider an array \emph{C} of n integers, initially all equal to zero. We want to support the following operations:
\begin{itemize}
    \item \textbf{update(i, j, c):} where $0 \leq i \leq j \leq n - 1$ and $c$ is an integer: it changes $C$ such that $C[k] = C[k] + c$ for every $i \leq k \leq j$.
    \item \textbf{query(i)} where $0 \leq i \leq n - 1$: it returns the value of $C[i]$.
    \item \textbf{sum(i,j)} where $0 \leq i \leq j \leq n - 1$: it returns $\Sigma_{k = 1}^{j}(C[k])$.
\end{itemize}
Design a data structure that uses $O(n)$ space and implements each operation above in $O(\log(n))$ time. Note that $query(i) = sum(i, i)$ but it helps to reason. [Hint to further save space: use an implicit tree such as the Fenwick tree (see wikipedia).]

\subsection{Solution 1: Fenwick lazy a-b sums}
Let $T$ be an segmented binary tree over a continuous interval $I: [0, N - 1]$ s.t. its leafs are the points in I, and the parent of two nodes comprises of their interval:
\begin{equation*}
  n' \cup n'' = n, n' \cap n'' = \emptyset   \textrm{ s.t. n is the father of n', n''}
\end{equation*}
$T$ will keep track of the prefix sums for every interval.
We define a function $s': [0, n - 1] \to \mathbb{N}$ that given a node in $T$ returns the sum of that interval.
The lazy algorithm doesn't propagate sums over $T$ as they are streamed in the input, which means $s'(i)$ might not be accurate.
In order to obtain our \emph{lazy} approach we define a function
$l: \mathbb{N} \to (\mathbb{N} \cup \{\epsilon\}, \mathbb{N})$
to keep track of our lazy sums:
\begin{equation*}
    s(n) = \begin{cases}
            \epsilon, _             &   \textrm{if no lazy prefix sum is in that interval} \\
            k, m                    &   \textrm{if a lazy sum of k is to be propagated to m}\\
            \end{cases}
\end{equation*}
The \emph{query} function is then trivial:

\begin{algorithmic}[1]
  \Function{query}{$I$, $i$, $sum$}:
    \State \If{$I.size == 1$}                       \Comment{Return found value}
        \State \Return $I.sum$\;

    \State \If{lazy(I), $i \in I.left$}             \Comment{Lazy on left child}
        \State lazy(I) = \False\;
        \State query($I.left$, $i$, $sum + I.sum$)
    \EndIf
    \State \If{lazy(I), $i \in right_child$}        \Comment{Lazy on right child}
        \State lazy(I) = \False\;
        \State query($I.right$, $i$, $sum + I.sum$)
    \EndIf

    \State \If{!lazy(I), $i \in I.left$}             \Comment{Not lazy on left child}
        \State query($I.left$, $i$, $sum$)
    \EndIf
    \State \If{!lazy(I), $i \in right_child$}        \Comment{Not lazy on right child}
        \State query($I.right$, $i$, $sum$)
    \EndIf
    \EndFunction
\end{algorithmic}
\end{document}

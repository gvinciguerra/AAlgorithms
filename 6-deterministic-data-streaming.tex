\section{Deterministic data streaming}

Consider a stream of n items, where items can appear more than once. The problem is to find the most frequently appearing item in the stream (where ties are broken arbitrarily if more than one item satisfies the latter). For any fixed integer $k \geq 1$, suppose that only $k$ items and counters can be stored, one item per memory cell, where each counter can use only $O(polylog(n))$ bits (i.e. $O(log^c n)$ for any fixed constant $c > 0$): in other words, only $b = O(k\cdot polylog(n))$ bits of space are available. (Note that, even though we call them counters, they can actually contain any kind of information as long as it does not exceed that amount of bits.)Show that the problem cannot be solved deterministically under the following rules: the algorithm can only use $b$ bits, and read the next item of the stream, one item at a time. You, the adversary, have access to all the stream, and the content of the $b$ bits stored by the algorithm: you cannot change those $b$ bits and the past, namely, the items already read by the algorithm, but you can change the future, namely, the next item to be read. Since the algorithm must be correct for any input, you can use any amount of streams to be fed to the algorithm and as many distinct items as you want. [Hint: it is an adversarial argument based on the fact that, for many streams, there can be a tie on the items.]

\vspace{0.5cm}
\paragraph{Solution.} We, the adversaries, can decide the alphabet $\Sigma$ and the content of the stream $s\in \Sigma^*$. The \emph{idea} is to create a stream generator that forces any deterministic algorithm to reach a configuration with at least two different streams. In fact, the number of configurations of memory for this class of algorithms is bounded because of $b$ and, by the pigeonhole principle, there exist at least two streams that cause the algorithm to transition the same configuration.

There are $2^b$ possible configurations of the memory. If we use an alphabet $\Sigma$ such that $|\Sigma|=2^b$, then the algorithm would need $log_2|\Sigma| = b$ bits to distinguish each symbol. Intuitively, given such alphabet, if we feed the stream with streams $s\in\Sigma^*$, then the algorithm can neither store (any representations of) the elements of the stream without loosing information, nor information about the stream, such as counters. We therefore create a class of streams:
$$\mathcal{S}_\Sigma = \{s \mid s \text{ contains all the symbols in } \Sigma \text{ and there is a tie on frequencies} \}$$
Note that $\forall s \in \mathcal{S}_\Sigma$, $|s|\geq|\Sigma|$, hence we can apply the pigeonhole principle:
suppose that the same configuration is reached in two different executions of the algorithm with the two streams $\alpha \in \mathcal{S}_{\Sigma_1}$ and $\beta \in \mathcal{S}_{\Sigma_2}$, where $|\Sigma_1|=|\Sigma_2|=2^b$ and $\Sigma_1 \cap \Sigma_2 = \emptyset$.
When we will emit $a \in \Sigma_1$ as next character of the stream and query the algorithm for the most frequent item, we will receive an answer $\mathcal{A}$. The algorithm is deterministic, therefore in the same configuration the answer will be the same for each stream. But $\mathcal{A}$ will be wrong for at least one of the two streams, because they have different alphabets.


\begin{table}[h]
  \centering
  \begin{tabular}{l|l|l|l|l|l|l|}
    \cline{2-7}
    stream $\alpha \in \mathcal{S}_{\Sigma_1}$ & ... & d & e & f & g & h \\ \cline{2-7} 
    stream $\beta \in \mathcal{S}_{\Sigma_2}$ & ... & 4 & 5 & 6 & 7 & 8 \\ \cline{2-7} 
  \end{tabular}
\end{table}
